#!/bin/bash
#
# this file contains common code for the btrfs maintenance scripts
#

# function: evaluate_auto_mountpoint
# parameter: A variable name
#
# this function checks whether the variable contains the special keyword "auto"
# if yes, all currently mounted btrfs filesystems are evaluated and their mountpoints
# are put into the parameter variable
evaluate_auto_mountpoint() {
	MOUNTPOINTSVAR=\$"$1"
	if [ "$(eval "expr \"$MOUNTPOINTSVAR\"")" = "auto" ]; then
		local BTRFS_DEVICES=""
		local DEVICE=""
		local MNT=""
		local MNTLIST=""
		# find all mounted btrfs filesystems, print their device nodes, sort them
		# and remove identical entries
		BTRFS_DEVICES=$(findmnt --types btrfs --output "SOURCE" --nofsroot --noheading | sort | uniq)
		# find one (and only one) corresponding mountpoint for each btrfs device node
		for DEVICE in $BTRFS_DEVICES; do
			MNT=$(findmnt --types btrfs --first-only --noheadings --output "TARGET" --source "$DEVICE")
			if [ -n "$MNTLIST" ]; then
				MNTLIST="$MNTLIST:$MNT"
			else
				MNTLIST="$MNT"
			fi
		done
		echo "evaluate mounted filesystems: $MNTLIST"
		eval "$1=$MNTLIST"
	fi
}

# function: detect_mixed_bg
# parameter: path to a mounted filesystem
#
# check if the filesystem contains mixed block groups,
detect_mixed_bg() {
	# simple test is to read 'btrfs fi df',
	# (we could look for /sys/sfs/btrfs/UUID/allocation/mixed if we know
	# the UUID)

	btrfs filesystem df "$1" | grep -q "Data+Metadata"
}

# function: check_scrub_running
# parameter: path to a mounted filesystem
#
# check if scrub is in progress on a given filesystem, return 0 if it is so
check_scrub_running() {
	btrfs scrub status "$1" | grep -q "scrub.*running for"
}

# function: check_balance_running
# parameter: path to a mounted filesystem
#
# check if balance is in progress on a given filesystem, return 0 if it is so
check_balance_running() {
	# 0: not in progress
	# 1: in progress
	# 2: other error (EPERM)
	if btrfs balance status "$1" >& /dev/null; then
		return 1
	fi
	return 0
}

# function: wait_on_lock_dir
# parameter: directory full path and timeout
#
# Wait the non-existence and then create a locking directory
wait_on_lock_dir() {
	local lockdir="${1%%/}"
	local basedir=${lockdir%/*}
	local timeout=$2
	local timecount=0

	[ -z "$2" ] && timeout="infinite"

	mkdir -p "$basedir"
	while ! mkdir "$lockdir" &>/dev/null; do
		[ "$timeout" != "infinite" ] && [ $timecount -ge $timeout ] && return 1
		sleep 1s
		timecount=$(($timecount+1))
	done

	return 0
}

# function: unlock_dir
# parameter: path to the lock directory
#
# Remove the locking directory
unlock_dir() {
	local lockdir="${1%%/}"
	local basedir=${lockdir%/*}

	rmdir "$lockdir" &>/dev/null
}

# function: get_disk_name
# parameter: path to a mounted filesystem
#
# return the disk device name (without any directory prefix and 
# without any partition number suffix) that contain the passed path
get_disk_name() {
	local path="$1"
	local dev="$(df --output=source $path|awk 'END {print $1}')"

	local diskdev="${dev%%[0-9]*}"
	local disk="${diskdev##*/}"

	echo $disk
}
